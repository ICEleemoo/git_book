\documentclass{article}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{colortbl}

\title{Try Git}
\author{\Large leemoo}
\begin{document}
\maketitle
\tableofcontents

\section{Got 15 minutes and want to learn Git?}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
	Git allows groups of people to work on the same documents(often code) at the same time, and without stepping on each other's toes. It's a distributed version control system. \\
	Our terminal prompt below is currently in a directory we decided to name ``octobox". To initialize a Git repository here, type the following command: \\%
	}
\hfill
\begin{tabular}{ll}
\rowcolor{lightgray} \$ git init \\
\end{tabular}%
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth }
	\fbox{
		\parbox{\textwidth}{\tiny{
			\textbf{Directory:}\\
			A folder used for storing multiples files.\\
			\textbf{Repository:}\\
			A directory where Git has been initialized to start version controlling your files.\\
			\textbf{Clicky Click:}\\
			Click on the instructions preceded by an arrow. They will be copied into the terminal prompt.\\ }
		}
	}
\end{minipage} 


\section{Checking the Status}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Good job! As Git just told us, ``octobox" directory now has an empty repository in \textbf{/.git/}. The repository is a hidden directory where Git operates.\\
			To save your progress as you go through this tutorial -- and earn a badge when you successfully complete it -- head over to \textbf{ create a free Code School account}. We'll wait for you here.\\
			Next up, let's type the \textbf{git status} command to see what the current state of our project is:
	}
	\begin{tabular}{ll}
		\rowcolor{lightgray} \$ git status\\
	\end{tabular}

\end{minipage}%
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
			\textbf{The .git directory:}\\
				One the left you'll notice a \textbf{.git} directory. It's usually hidden but we're showing it to you for convenience.\\
				If you dick it you'll notice it has all sorts of direcotries and files inside it. You'll rarely ever need to do anything inside here but it's the guts of Git, where all the magic happens.\\
			}
		}
	}
\end{minipage}

\section{Adding \& Committing}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		I created a file called \textbf{octocat.txt} in the octobox repository for you( as you can see in the browser below).\\
		  You should run the \textbf{git status} command again to see how the repository status has changed:\\
	  
	\colorbox{lightgray}{ \$ git status}\\
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				It's healthy to run \textbf{git status} often. Sometimes things change and you don't notice it.
			}
		}
	}
\end{minipage}

\section{ Adding Changes}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Good, it looks like our Git repository is working properly. Notice how Git says \textbf{octocat.txt} is ``untracked"? That means Git sees that \textbf{octocat.txt} is a new file.\\
		To tell Git to start tracking changes made to \textbf{octocat.txt}, we first need to add it to the staging area by using git add.\\
		\colorbox{lightgray}{git add octocat.txt}\\
	}%
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{\tiny
			\textbf{staged}:\\
			Files are ready to be committed.\\
			\textbf{unstaged}:\\
			Files with changes that hve not been prepared to be committed.\\
			\textbf{untracked}:\\
			Files aren't tracked by Git yet. This usually indicates a newly created file.\\
			\textbf{deleted}:\\
			File has been deleted and is waiting to be removed from Git.\\
		}
	}
\end{minipage}

\section{Checking for Changes}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Good job! Git is now tracking our \textbf{octocat.txt} file. Let's run \textbf{git status} again to see where we stand:\\
		\colorbox{lightgray}{git status}
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{add all}:\\
				You can also type \textbf{git add -A}. where the dot stands for the current directory, so everything in and beneath it is added. The \textbf{-A} ensures even file deletions are included.\\
				\textbf{git reset}:\\
				You can use \textbf{git reset <filename> } to remove a file or files from the staging area.\\
			}
		}
	}
\end{minipage}

\section{Committing}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Notice how Git says \textbf{ changes to be committed}? The files listed here are in the \textbf{Staging Area}, and they are not in our repository yet. We could add or remove files from the stage before are store them in the repository.\\
		To store our staged changes we run the \textbf{commit} command with a message describing what we've changed. Let's do that now by typing:\\
		\colorbox{lightgray}{ git commit -m `` Add cute octocat story"}\\
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
	\parbox{\textwidth}{
		\tiny{
			\textbf{Staging Area}:\\
			A place where we can group files together before we ``commit" them to Git.\\
			\textbf{Commit}:\\
			A ``commit" is a snapshot of our repository. This way if we ever need to look back at the changes we've made (or if someone else does), we will see a nice timeline of all changes.\\
		}
	}
}
\end{minipage}

\section{Adding All Changes}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Great! You also can use widcards if you want to add many files of the same type. Notice that I've added a bunch of \textbf{.txt} files into your directory below.\\
		I put some in a directory named ``octofamily" and some others ended up in the root of our ``octobox" directory. Luckily, we can add all the new files using a wildcard with \textbf{git add}. Don't forget the quotes!\\
		\colorbox{lightgray}{ git add `*.txt'}
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
			\textbf{Wildcards}:\\
			We need quotes so that Git will receive the wildcard before our shell can interfere with it.\\
			Without quotes our shell will only execute the wildcard search within the current direcotry. Git will receive the list of files the shell found instead of the wildcard and it will not be able to add the fiels inside of the octofamily directory.\\
		}
	}
	}
\end{minipage}

\section{Committing All Changes}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Okay, you've added all the text files to the staging area. Feel free to run git status to see what you're about to commit.\\
		If looks good, go ahead and run:\\
		\colorbox{lightgray}{ git commit -m `Add all the octocat txt files' }\\
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{ Check all the things!}:\\
				When using wildcards you wnat to be extra careful when doing commits. Make sure to check what files and flders are staged by using \textbf{git status} before you do the actual commit. This way you can be sure you're committing only the things you want.
			}
		}
	}
\end{minipage}

\section{History}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		So we've made a few commits. Now let's brwser them to see what we changed.\\
		Fortunately for us, there's \textbf{git log}. Think of Git's log as a journal that remembers all the changes we've committed so far, in the order we committed them. Try running it now:\\
		\colorbox{lightgray}{ git log}
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{More useful logs}:\\
				Use \textbf{git log --summary} to see more information for each commit. You can see where new files were added for the first time or where files were deleted. It's a good overview of what's going on in the project.}
		}
	}
\end{minipage}

\section{Remote Repositories}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Great job! We've gone ahead adn created a new empty Github repository for you to use with Try Git at \href{https://github.com/try-git/try\_git.git}{https://github.com/try-git/try\_git.git}. To push our local repo to the GitHub server we'll need to add a remote repository.\\
		This command takes a remote name and a repositroy URL, which in your case is \href{https://github.com/try-git/try\_git.git}{https://github.com/try-git/try\_git.git}.\\
		Go ahead and run \textbf{git remote add} with the options below:\\
		\colorbox{lightgray}{git remote add  origin https://github.com/try-git/try\_git.git}.\\
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{git remote}:\\
				Git doesn't care what you name your remotes, but it's typical to name your main one \textbf{origin}.\\
			It's also a good idea for your main repository to be on a remote server like GitHub in case your machine is lost at sea druing atransatlantic boat cruise or crushed by three monkey statues during an earthquake.
		}
	}
}
\end{minipage}

\section{Pushing Remotely}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		The push command tells Git where to put our commits when we're ready, and boy we're ready. So let's push our local changes to our origin repo(on GitHub).\\
		The name of our remote is \textbf{origin} and the default local branch name is \textbf{master}. The \textbf{-u} tells Git to remember the parameters, so that next time we can simply run \textbf{git push} and Git will know what to do. Go ahead and push it!\\
	\colorbox{lightgray}{ git push -u origin master}\\
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{Cool Stuff}:\\
				When you start to get the hang of git you can do some really cool things with \textcolor{red}{\textbf{hooks}} when you push.\\
				For example, you can upload directly to a webserver whenever you push to your master remote instead of having to upload your site with an ftp client. Check out Customizing Git-git Hooks for more information.\\
			}
		}
	}
\end{minipage}

\section{Pulling Remotely}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Let's pretend some time has passed. We've invited other people to our github project who have pulled your changes, made their own commits, and pushed them.\\
		We can check for changes on our GitHub repository and full down any new changes by running:\\
		\colorbox{lightgray}{ git pull origin master}\\
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{git stash}:\\
				Sometimes when you go to pull you may have changes you don't want to commit just yet. One option you have, other than commiting is to stash the changes.\\
				Use the command `\textcolor{blue}{git stash}' to stash your changes, and `\textcolor{blue}{git stash apply}' to re-apply your changes after your pull.
			}
		}
	}
\end{minipage}

\section{Differences}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Uh oh, looks like there have been some additions and changes to the octocat family. Let's take a look at what is different from our last commit by using the \textcolor{red}{\textbf{git diff}} command.\\
		In this case we wwant the diff of our most recent commit, which we can refer to using the \textbf{HEAD} pointer.\\
		\colorbox{lightgray}{ git diff HEAD}\\
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{HEAD}:\\
				The HEAD is a pointer that holds your position within all your different commits. by default HEAD points to your most recent commit, so it can be used as a quick way to reference that commit without having to look up the SHA.
			}
		}
	}
\end{minipage}

\section{Staged Differences}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Another great use for \textbf{diff} is looking at changes within files that have already been staged. Remember, staged files are files we have told git that are ready to be committed.\\
		Let's use \textbf{git add} to stage \textbf{octofamily/octodog.txt}, which I just added to the family for you.\\
		\colorbox{lightgray}{ git add octofamily/octodog.txt}\\
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{Commit Etiquette}:\\
				You want to try to keep related changes together in separate commits. Using `\textcolor{blue}{\textbf{git diff}}' gives you a good overview of changes you have made and lets you add files or directories one at ta time and commit them separately.
			}
		}
	}
\end{minipage}

\section{Staged Differences(cont'd)}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Good, now go ahead and run \textbf{git diff} with the \textbf{--staged} option to see the changes you just staged. You should see that \textbf{octodog.txt} was created.\\
		\colorbox{lightgray}{ git diff --staged}\\
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{Commit Etiquette}:\\
				You want to try to keep related changes together in separate commits. Using `\textbf{git diff}' gives you a good overview of changes you have made and lets you add files or directories one at a time and commit them separately.
			}
		}
	}
\end{minipage}

\section{Resetting the Stage}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		So now that octodog is part of the family, octocat is all depressed. Since we love octocat more than octodog, we'll turn his frown around by removing \textbf{octodog.txt}.\\
		You can unstage files by using the \textbf{git reset} command. Go ahead and remove \textbf{octofamily/octodog.txt}.\\
		\colorbox{lightgray}{ git reset octofamily/octodog.txt}
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{Commit Etiquette}:\\
				You want to try to keep related changes together in separate commits. Using `\textbf{git diff}' gives you a good overview of changes you have made and lets you add fiels or directories one at a time and commit them separately.
			}
		}
	}
\end{minipage}

\section{Undo}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		\textbf{git reset} did a great job of unstaging octodog.txt, but you'll notice that he's still there. He's just not staged anymore. It would be great if we could go back to how things were before octodog came around and ruined the party.\\
		Files can be changed back to how htey were at the last commit by using the command:\textbf{git checkout --<target>}. Go ahead and get rid of all the changes since the last commit for \textbf{octocat.txt}:\\
	\colorbox{lightgray}{git checkout -- octocat.txt}\\
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{The `--'}:\\
			So you may be wondering, why do I have to use this \textcolor{blue}{\textbf{`--'}} thing? \textcolor{blue}{\textbf{git checkout}} seems to work fine without it. It's simply promising the command line that there are no more options after the \textcolor{blue}{\textbf{`--'}}. This way if you happen to have a branch named \textbf{octocat.txt}, it will still revert the file, instead of switching to the branch of the same name.}
		}
	}
\end{minipage}

\section{Branching Out}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		When developers are working on a feature or bug they'll often create a copy (aka. \textbf{branch})of their code they can make separate commits to. Then when they're done they can merge this branch back into their main master branch.\\
		We want to remove all these pesky octocats, so let's create a branch called \textbf{clean\_up}, where we'll do all the work:\\
		\colorbox{lightgray}{git branch clean\_up}\\
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{Branching}:\\
				Branches are what naturally happens when you want to work on multiple featrues at the same time. You wouldn't to end up with a master branch which has Feature A half done and Feature B half done.\\
				Rather you'd separate the code base into two ``snpshots" (branches) and work on and commit to them separately. As soon as one was ready, you might merge this brqanch back into the master branch and push it to the remote server.\\
			}
		}
	}
\end{minipage}

\section{Swithcing Branches}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Great! Now if you type \textbf{git branch} you'll see two local branches: a main branch named \textbf{master} and your new branch named \textbf{clean\_up}.\\
		You can swith branches using the \textbf{git checkout <branch>} command. Try it now to swith to the \textbf{clean\_up} branch:\\
		\colorbox{lightgray}{git checkout clean\_up}
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{All at Once}:\\
				You can use:\\
				\colorbox{yellow}{git checkout -b new\_branch} to checkout and create a branch at the same time. This is the same thing as doing:\\
				\colorbox{yellow}{git branch new\_branch}\\
				\colorbox{yellow}{git checkout new\_branch}\\
			}
		}
	}
\end{minipage}

\section{Removing All The Things}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Ok, so you're in the \textbf{clean\_up} branch. You can finally remove all those pesky octocats by using the \textbf{git rm} command which will not only remove the actual files from disk, but wil also stage the removal of the fiels for us. \\
		You're going to want to use a wildcard again to get allthe octocats in one sweep, go ahead and run:\\
		\colorbox{lightgray}{git rm `*.txt'}
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{Remove all the things}!\\
				Removing one file is great and all, but what if you want to remove and entire folder? You can use the recursive option on git rm:\\
				\colorbox{yellow}{git rm -r folder\_of\_cats} This will recurisively remove all folders and files from the given directory.
			}
		}
	}
\end{minipage}

\section{Commiting Branch Changes}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Now that you've removed all the cats you'll need to commit your changes. \\
		Feel free to run \textbf{git status} to check the changes you're about to commit:\\
		\colorbox{lightgray}{ git commit -m ``Remove all the cats"}
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{ The `-a' option}\\
				If you happen to delete a file without using \colorbox{yellow}{git rm} you'll find that you still have to \colorbox{yellow}{git rm} the deleted files from the working tree. You can save this step by using he \colorbox{yellow}{-a} option on \colorbox{yellow}{git commit} which auto removes deleted files with the commit. \colorbox{yellow}{git commit  -am ``Delete stuff"}
			}
		}
	}
\end{minipage}

\section{Switching Backing to master}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Great, you're almost finished with the cat... er the bug fix, you just need to switch back to the \textbf{master} branch so you can copy(or \textbf{merge}) your chanes from the \textbf{clean\_up} branch back into the master branch.\\
		Go ahead and checkout the master branch:\\
		\colorbox{lightgray}{ git checkout master}
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{Pull Requests}\\
				If you're hosting your repo on GitHub, you can do somethng called a pull request.\\
				A pull request allows the boss of the project to look through your changes and make comments before deciding to merge in the change. It's a really great feature that is used all the time for remote workers and open source projects. \\
				Check out the \textbf{pull request help page} for more information.
			}
		}
	}
\end{minipage}

\section{Preparing to Merge}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Alrighty, the moment has come when you have to merge your changes from the \textbf{clean\_up} branch into the \textbf{master} branch. Take a deep breath, it's not that scary.\\
		We're already on the \textbf{master}branch, so we just need to tell Git to merge the \textbf{clean\_up} branch into it:\\
		\colorbox{lightgray}{git merge clean\_up}
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{ Merge conflicts}\\
				Merge Confilicts occur when changes are made to a file at the same time. A lot of people get really scared when a conflict happens, but fear not! They aren't that scary you just need to decide which code to keep.\\
			Merge conflicts are beyond the scope of this course, but if you're interested in reading more, take a look the section of the \textbf{Pro Git book} on how conflicts are presented.}
		}
	}
\end{minipage}

\section{keeping Things Clean}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Congratulations! You just accomplished your first successful bugfix and merge. All that's left to do is clean up after yourself. Since you're done with the \textbf{clean\_up} branch you don't need it anymore.\\
		You can use \textbf{git branch -d <branch name>} to delete a branch. Go ahead and delete the \textbf{clean\_up} branch now:\\
		\colorbox{lightgray}{git branch -d clean\_up} 
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{\tiny{
			What if you have been working on a feature branch and you decide you really don't want this feature anymore? You might decide to delete the branch since you're scrapping the idea. You'll notice that \textbf{git branch -d bad\_feature} doesn't work. This is because \textbf{-b} won't let you delete something that hasn't been merged.\\
			You can either add the \textbf{--force (-f) } option or use \textbf{-D} which combines \textbf{-b -f} together into one command.
			}
		}
	}
\end{minipage}

\section{The Final Push}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Here we are, at the last step. I'm pround that you've made it this far, and it's been great learning Git with you. All that's left for you to do now is to push everything you've been working on to your remote repository, and you're done!\\
		\colorbox{lightgray}{git push}
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{Learning more about Git}\\
				We only scratched the surface of Git in this course. There is so much more you can do with it. Check out the \textbf{Git documentation} for a ful list of functions.\\
				The \textbf{Pro Git book}, by Scott Chacon, is an excellent resource to teach you the inner workings of Git. \textbf{help github} and GitHub Training are also great for anything related to Git in general and using git with GitHub.
			}
		}
	}
\end{minipage}

\section{The Final Push}
\begin{minipage}[c]{0.66\textwidth}
	\parbox{\textwidth}{
		Great! You now have a little taste of the greatness of Git. You can take a look at the wrap up page for a little more information on Git and GitHub, on, and of course your badge!\\
		\colorbox{cyan}{Wrap it all Up}
	}
\end{minipage}
\hfill
\begin{minipage}[c]{0.32\textwidth}
	\fbox{
		\parbox{\textwidth}{
			\tiny{
				\textbf{Learning more about Git}\\
				We only scratched the surface of Git in this course. There is so much more you can do with it. Check out the \textbf{Git documentation} for a ful list of functions.\\
				The \textbf{Pro Git book}, by Scott Chacon, is an excellent resource to teach you the inner workings of Git. \textbf{help github} and GitHub Training are also great for anything related to Git in general and using git with GitHub.
			}
		}
	}
\end{minipage}

\end{document}
